// types and values are eqivalent, alias is a special thing that refers to a type.

1 // literal numeric constant
0xff
0b00001011 // various ways to represent. "infinite size" is permitted. can only cast to equiv or bigger type

"data of some kind" // literal string

.{} // literal struct;
.{VT:KEY; VT:KEY;}

.[] // literal array;
.[VT, VT]

{} // locical literal;
{
	// logic
}

// ALL LITERALS MUST BE "CAST" to be used.

// push values into registers
// call the function

(3, 4, 10) | my_proc;

{a + b + c | #break;}
| (int:a, int:b, int:c |> int) :: my_proc;

(i32, i32 $> i32)::[]:mything; // mutable ptr "[]" to proc

"Hello world" $ my_proc;


{
	// free memory or something...
} | #defer; // passing a block of code to a function...

|{
	// scoped code execution...
};

${
	// enforce compile time code execution...
}

i32 -> #no_return

|> #out_type :: proc_y;
{ abstract_expression } |> #out_type :: proc_y;

//////////////////////////// VARIABLES

// Types are intrinsically tied to values and cannot be seperated, only some types are valid during runtime. 
// An alias cannot be independant of a value/type 

3; // 3 is type #abstract_number
i64; // uninialized i64
alias; // ERROR undefined symbol "alias"

// : indicates, mutable alias, value can change. (read write)
// :: indicates, immutable alias, value cannot change. (read only)

3 | i64; // cast/load 3 into i64. tldr: create an i64 with a value of 3

i64 : alias; // alias is an uninitalized i64.
i64 :: alias; // alias is an uninitalized i64.

3 : alias; // mutable numeric constant, only allowed under compile time.
3 :: alias; // immutable numeric constant.

3|i64 : alias; // alias to an i64 with a value of 3.
3|i64 :: alias; // alias to an i64 with a value of 3.


//////////////////////////// VARIABLE OVERWRITE

1 | i32 : alias;
2 | i32 : other_alias;
(alias + other_alias) | i32 :: result; 

1 | i64 : alias;
alias + other_alias :: result; // ERROR, type mismatch.

alias|i32 + other_alias :: result;


//////////////////////////// PROCEDURES TYPE DEFINTION
// NOTE in this language procedures only take in a single type/value.

// procedure type definition minimal
!! out_type; 
!! out_type : alias;
!! out_type :: alias;

// procedure type definition minimal input.
in_type !! out_type; 
in_type !! out_type : alias;
in_type !! out_type :: alias;


//////////////////////////// PROCEDURES DEFINTION

// procedure type definition minimal
{ LOGIC } !! out_type; 
{ LOGIC } !! out_type : alias;
{ LOGIC } !! out_type :: alias;

// procedure type definition minimal input.
in_type { LOGIC } !! out_type; 
in_type { LOGIC } !! out_type : alias;
in_type { LOGIC } !! out_type :: alias;


//////////////////////////// PROCEDURE CALL

input_data ! procedure_alias;
input_data ! procedure_alias : alias;
input_data ! procedure_alias :: alias;


//////////////////////////// COMPILE TIME
// Via replacing ! and !! with $ and $$ you can go to compile time execution.
// $ enforces compile time always
// ! will try for compile time if possible

$$ out_type; 
$$ out_type : alias;
$$ out_type :: alias;

in_type $$ out_type; 
in_type $$ out_type : alias;
in_type $$ out_type :: alias;

{ LOGIC } $$ out_type; 
{ LOGIC } $$ out_type : alias;
{ LOGIC } $$ out_type :: alias;

in_type { LOGIC } $$ out_type; 
in_type { LOGIC } $$ out_type : alias;
in_type { LOGIC } $$ out_type :: alias;

input_data $ procedure_alias;
input_data $ procedure_alias : alias;
input_data $ procedure_alias :: alias;


//////////////////////////// SCOPE

{
  1 | i64:alias;
  
  {
    1 | i64:other_alias;
    alias + other_alias;
  };
  
  other_alias + 3; // ERROR undefined symbol "other_alias"
};

//////////////////////////// Example code?

"base:memory" $ #import_lib :: memory_lib;

4 !memory_lib.generic_alloc : bytes_n_stuff;
!bytes_n_stuff.free $ #defer;

.{ f64:left, f64:right } {
    left + right | #return;
} !! f64 :: add_float;

{32.0, 20.0} $add_float :: my_var;

{20.0:right; 420.0:left;} !add_float : other_var;
 
////////////////////////////


